{"google":"","note":"Don't delete this file! It's used internally to help with page regeneration.","name":"Backbone.Ext","tagline":"Extensions for Backbone.js","body":"# Backbone Extensions\r\n\r\n## Example\r\n[Example contacts app](http://natefaubion.github.com/backbone.ext/example/)\r\n\r\n## Backbone.Ext.View\r\nExtends the default `Backbone.View` with placeholder methods for clearing the\r\nelement and doing any event handler cleanup. It also ensures that all view\r\nelements will have a `data-cid` attribute for referencing views so we can\r\ndirect delegated events to the correct child view.\r\n\r\n### view.release()\r\nModel cleanup. By default, checks for a `model` or `collection` and unbinds all\r\nevents on the `this` context.\r\n\r\n### view.clear()\r\nSets `$el.html` to an empty string.\r\n\r\n### view.setElement(element, [delegate])\r\nOverrides the default implementation to add a `data-cid` attribute on the\r\nview's `el`. This is needed during child-view event delegation for routing the\r\nevent to the correct view.\r\n\r\n### Backbone.Ext.View.enableElementProxy(methods...)\r\nProxy methods to each view's `$el`. Default methods are `show` and `hide`.\r\n\r\n\r\n## Backbone.Ext.CompositeView\r\nA special view that lets you register child views that can then have their\r\nevents delegated. This lets you write your child views like they are handling\r\ntheir own events, but have the parent CompositeView act as a delegate so you\r\ndon't have thousands of event handlers for views with many children. It also\r\nprovides a method for replacing placeholder elements with the correct child\r\nviews.\r\n\r\n```js\r\nvar MyView = Backbone.Ext.CompositeView.extend({\r\n  template: _.template(\"<%= this.placeholderFor(this.childView) %>\"),\r\n  initialize: function () {\r\n    this.childView = this.registerChild(new ChildView(), {\r\n      selector: \".child-view\"\r\n    });\r\n  },\r\n  render: function () {\r\n    this.$el.html(this.template());\r\n    this.placeChildren({render: true});\r\n    return this;\r\n  }\r\n});\r\n```\r\n\r\n### view.release()\r\nCalls `release` on all child views also.\r\n\r\n### view.clear()\r\nCalls `clear` on all child views and detaches them from the DOM so they won't\r\nlose their event handlers.\r\n\r\n### view.registerChild(childView, [options])\r\nRegisters the view as a child. Calling `relase` or `clear` on the parent will\r\nalso call it on any registered children. If `options.selector` is set, all\r\nchild views registered with the same selector will have their events delegated\r\nby the parent view rather than having handlers on individual children. If\r\n`options.at` is set, the child view will be inserted into `children` at the\r\nspecified index. Returns the supplied view.\r\n\r\nEvents are delegated based upon the `events` hash of the least recently\r\nregistered child for a given selector. If a view's events are a function that\r\nreturns a dynamic hash based upon some internal state, you should not use event\r\ndelegation.\r\n\r\nUse simple, yet specific, selectors when registering a child. The selector is\r\nused in two places: settings up event delegations on the parent and finding the\r\ntarget child view. The target child view is determined by walking up the DOM\r\nhierarchy using `$(e.currentTarget).closest(selector + '[data-cid]')` within\r\nthe event handler.\r\n\r\n### view.deregisterChild(childView, [options])\r\nDeregisters a view as a child. Returns the supplied view. Aliased to\r\n`unregisterChild`. If `options.at` is set, the view at the specified index will\r\nbe removed and the first paramater will be ignored.\r\n\r\n### view.placeChildren([options])\r\nFinds placeholder elements and replaces them with the correct view. If \r\n`options.render` is set, `render` will be called on each child view as it is \r\nplaced in the DOM.\r\n\r\n### view.placeholderFor(childView)\r\nGiven a view, returns a placeholder html string that can be used in a template\r\nand later replaced by `placeChildren`. The default implementation returns\r\na string in the form of `<view data-cid=\"view.cid\" />` by default. The\r\n`data-cid` attribute is used to lookup the correct replacement view. If you\r\noverride this method to return a different string, be sure to change\r\n`placeholderSelector` also.\r\n\r\n### view.delegateChildEvents()\r\nSets up event delegations for all child views registered with a selector.\r\n\r\n### view.undelegateChildEvents()\r\nRemoves event delegations for child views.\r\n\r\n### view.delegateEvents([events])\r\nOverriden to also call `delegateChildEvents`.\r\n\r\n### view.children\r\nAn array of the currently registered children. This should never be modified\r\ndirectly. Use `registerChild` and `deregisterChild` instead.\r\n\r\n### Backbone.Ext.CompositeView.placeholderSelector\r\nA string selector used to find placeholder elements. Defaults to `'view'`. This\r\ncan be set globally on `Backbone.Ext.CompositeView` or overridden on individual\r\nviews by setting an attribute of the same name.\r\n\r\n\r\n## Backbone.Ext.ListView\r\nA common pattern is to have a view that represents the state of a collection\r\nand its models. Given a `modelView` and `delegationSelector`, this will create\r\na list of a views that always stay synced with the supplied collection and\r\ndelegate the child views' events. This is designed to be lightweight yet\r\npowerful enough to not require subclassing. In most cases, it should be created\r\ndirectly by a parent CompositeView.  Consequently, it implements `initialize`\r\nand `render` methods. So if subclassing is required, make sure to keep that in\r\nmind.\r\n\r\n```js\r\nvar listView = new Backbone.Ext.ListView({\r\n  tagName: \"ul\",\r\n  modelView: ListItemView,\r\n  delegationSelector: \"li\",\r\n  collection: myCollection\r\n});\r\n```\r\n\r\n### view.syncViews()\r\nCreates a child view for each model in the view's collection, and registers it\r\nas a child. If a `delegationSelector` was supplied, it will make sure the\r\nevents are delegated by the list view. This is called automatically on view\r\ninitialization and on collection `refresh` events. You should not need to call\r\nthis manually unless overriding the default behavior.\r\n\r\n\r\n## Backbone.Ext.MultiRouter\r\nBackbone.History only allows one callback per route, but for more modular\r\napplications, it can be helpful to have multiple routers that may share the\r\nsame or similar routes but update different parts of the application. Write\r\nyour routers as you normally would using `Backbone.Router`, then use\r\n`MultiRouter` to glue them together. `MultiRouter` is also a router itself, so\r\nit can have routes and callbacks of its own which will be executed before other\r\nroutes.\r\n\r\n```js\r\nvar MyAppRouter = Backbone.Ext.MultiRouter.extend({\r\n  initialize: function () {\r\n    this.nav = this.createRouter(NavRouter);\r\n    this.todos = this.createRouter(TodosRouter);\r\n    this.notes = this.createRouter(NotesRouter);\r\n  }\r\n});\r\n```\r\n\r\n### multi.createRouter(routerClass, [options])\r\nA factory method to instanciate a new router. To multiplex your routes, the\r\nrouter must be created using `createRouter`. An optional `options` object will\r\nbe passed on to your new router.\r\n"}